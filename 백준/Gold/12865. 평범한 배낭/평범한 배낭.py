'''
1. 일단은 N개의 물건과 배낭 무게 제한이 K이고 각각의 물건은 무게가 W, 가치가 V이다.
2. 그래서 이거로 뭘 할거냐? 무게 K이하로 해서 가치를 최대화 할거야.
3. 보면 이전의 결과를 바탕으로 최대의 결과를 얻으려고 하기 때문에 DP를 사용해서 문제를 풀거야.
4. dp[i][w] = 처음 i개의 물건을 고려했을 때, 무게 w까지 사용 가능할 때의 최대 가치. 
   즉, dp[3][7]의 경우 물건 1, 2, 3번을 고려했을 때 무게 7kg까지 가능하고 이때의 최대 가치는 얼마???
5. 점화식을 도출할건데 여기서 중요한 점은 어떠한 물건을 고려할 때 우리가 선택할 수 있는 선택지는 2개이다. 이 물건을 가방에 넣을거야? 말거야?
6. 만약에 물건을 가방에 안넣으면? 그러면 이전의 가치가 최대가 되겠지. 즉 dp[i][w] = dp[i-1][w]가 되는거다.
7. 하지만 물건을 가방에 넣으면? 이때는 조금 복잡한데 무게가 전체 무게보다 작아야 할 것이고, dp[i][w] = dp[i-1][w-seight[i]] + value[i]가 된다.
   즉 현재 물건의 무게로 이전 물건들로 얻은 최대 가치와 현재 물건 가치를 더한 값이 저장이 되어야 할 것이다.
'''
N, K = map(int, input().split())
# 물건의 무게, 가치를 각각 담아줄 리스트 생성
weight = [0]
value = [0]

for _ in range(N):
    w, v = map(int, input().split())
    weight.append(w)
    value.append(v)

# DP 만들기 -> dp[i][w]로 i는 물건이 들어가고 w에는 무게가 들어가니까 K가 먼저 들어가기. 그리고 각 칸이 중요하니까 K개, N개 맞추는게 아니다. 0부터 시작을 해야한다.
dp = [[0] * (K + 1) for _ in range(N + 1)]    # 아무것도 못 넣은 상태로 이미 초기값 자체가 설정이 되어 있다. -> 물건을 고려하지 않는다... 이거 자체가 이미 초기값으로 설정을 한 것!

for i in range(1, N + 1):
    for w in range(1, K + 1):
        if w < weight[i]:   # 현재 허용 무게 w가 물건 무게인 weight[i]보다 작다면, 가방에 넣을 수가 없음
            dp[i][w] = dp[i-1][w]
        else:
            # 넣을지 말지 결정
            dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])

print(dp[N][K])