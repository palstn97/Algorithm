'''
왜 dp로 풀어야할까?
우선 중복 부분 문제이다. 즉 i번째 집의 최소 비용은 i-1번째 최소 비용을 그대로 가져와서 사용한다.
또한 최적 부분 구조이다. 전체 최적해는 부분 최적해로 구성이 된다.
또한 이전 계산 결과를 재활용하는 메모이제이션 관련한 문제이다.

이 문제를 푸는데의 핵심은 다음과 같다.
dp[i][색] = i번째 집을 그 색으로 칠했을 때 최소 비용
점화식은 다음과 같다.
dp[i][빨강] = min(이전 초록, 이전 파랑) + 현재 빨강 비용
dp[i][초록] = min(이전 빨강, 이전 파랑) + 현재 초록 비용
dp[i][파랑] = min(이전 빨강, 이전 초록) + 현재 파랑 비용

쉬운 문제는 아니다. 나중에 반드시 다시 풀어볼 것!!!
'''
N = int(input())
house = [list(map(int, input().split())) for _ in range(N)]

dp = [[0] * 3 for _ in range(N)]

# 첫 번째 집 초기화
dp[0][0] = house[0][0]  # 1번 집을 빨강으로 칠했을 때 최소 비용
dp[0][1] = house[0][1]  # 1번 집을 초록으로 칠했을 때 최소 비용
dp[0][2] = house[0][2]  # 1번 집을 파랑으로 칠했을 때 최소 비용

for i in range(1, N):   # 1번 집은 위에서 초기화 했으니까
    # i번째 집을 빨강으로 칠했을 때의 최소 비용
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + house[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + house[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + house[i][2]

# 그러면 뭘 출력해야 하느냐? 가장 마지막 집의 최소 비용을 출력 하면 된다.
# 인덱스가 0부터 시작하니까 dp[N-1]
print(min(dp[N-1]))